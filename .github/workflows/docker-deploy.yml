name: Docker Deploy to Server

on:
  workflow_run:
    workflows: ["Docker Build and Push"]
    types:
      - completed
    branches: [labs3]

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}
  DEPLOY_HOST: course.prafdin.ru
  DEPLOY_USER: ryzhova
  DEPLOY_PORT: 2200
  APP_URL: http://app.ryzhova.course.prafdin.ru

jobs:
  deploy:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      with:
        ref: labs3

    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.7.0
      with:
        ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

    - name: Configure SSH known hosts
      run: |
        mkdir -p ~/.ssh
        ssh-keyscan -p ${{ env.DEPLOY_PORT }} ${{ env.DEPLOY_HOST }} >> ~/.ssh/known_hosts
        chmod 644 ~/.ssh/known_hosts

    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Get latest image tag
      id: get-tag
      run: |
        TAG=$(curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
          "https://api.github.com/users/${{ github.repository_owner }}/packages/container/${{ github.event.repository.name }}/versions" \
          | jq -r '.[0].metadata.container.tags[0]')
        echo "TAG=${TAG:-labs3}" >> $GITHUB_OUTPUT
        echo "Using tag: ${TAG:-labs3}"

    - name: Deploy to production server
      env:
        FULL_IMAGE_NAME: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.get-tag.outputs.TAG }}
      run: |
        echo "Deploying image: $FULL_IMAGE_NAME"
        
        # SSH –∫–æ–º–∞–Ω–¥—ã –¥–ª—è –¥–µ–ø–ª–æ—è
        ssh -o StrictHostKeyChecking=no -p ${{ env.DEPLOY_PORT }} \
          ${{ env.DEPLOY_USER }}@${{ env.DEPLOY_HOST }} << 'EOF'
        
        # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
        log() {
          echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
        }
        
        log "Starting deployment..."
        
        # –õ–æ–≥–∏–Ω –≤ registry
        echo "${{ secrets.GITHUB_TOKEN }}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
        
        # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∏ —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        log "Stopping old container..."
        docker stop website-container 2>/dev/null || true
        docker rm website-container 2>/dev/null || true
        
        # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –æ–±—Ä–∞–∑—ã
        log "Cleaning up old images..."
        docker image prune -af --filter "until=24h"
        
        # –°–∫–∞—á–∏–≤–∞–µ–º –Ω–æ–≤—ã–π –æ–±—Ä–∞–∑
        log "Pulling new image: $FULL_IMAGE_NAME"
        docker pull "$FULL_IMAGE_NAME"
        
        # –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
        log "Starting new container..."
        docker run -d \
          --name website-container \
          --restart unless-stopped \
          --log-opt max-size=10m \
          --log-opt max-file=3 \
          -p 80:80 \
          -p 443:443 \
          -e NGINX_ENV=production \
          "$FULL_IMAGE_NAME"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç–∞—Ç—É—Å –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä–∞
        sleep 5
        log "Container status:"
        docker ps --filter "name=website-container" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        log "Checking application health..."
        if curl -s -f http://localhost:80 > /dev/null; then
          log "‚úì Application is healthy and responding"
        else
          log "‚úó Application health check failed"
          exit 1
        fi
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–µ—Ç–µ–≤—É—é –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å
        log "Checking network accessibility..."
        docker exec website-container nginx -t
        docker exec website-container curl -s http://localhost:80 > /dev/null
        
        log "Deployment completed successfully!"
        
        EOF

    - name: Verify deployment
      run: |
        echo "Waiting for application to be ready..."
        sleep 10
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        MAX_RETRIES=10
        RETRY_COUNT=0
        
        while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
          if curl -s -f ${{ env.APP_URL }} > /dev/null; then
            echo "‚úì Application is accessible at: ${{ env.APP_URL }}"
            break
          else
            RETRY_COUNT=$((RETRY_COUNT+1))
            echo "Attempt $RETRY_COUNT/$MAX_RETRIES: Application not ready yet..."
            sleep 5
          fi
        done
        
        if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
          echo "‚úó Application failed to become accessible"
          exit 1
        fi

    - name: Create deployment status
      if: always()
      run: |
        if [ "${{ job.status }}" == "success" ]; then
          echo "‚úÖ Deployment successful!"
          echo "üì¶ Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ steps.get-tag.outputs.TAG }}"
          echo "üåê URL: ${{ env.APP_URL }}"
          echo "üïê Time: $(date)"
        else
          echo "‚ùå Deployment failed!"
          echo "Please check the logs above for details."
        fi
